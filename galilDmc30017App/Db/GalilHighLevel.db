######################################################################
#
#            Galil DMC 30017 High Level Record Database
#
# Desc: These records provide an abstraction layer for
# the Galil Driver records.

#####################################################################
# ALIASES
#
# Desc: Aliases for the Galil Driver records.

# Motor Record
# Source: <Galil support top directory>/GalilSup/Db/galil_motor.template
alias(  "$(P)$(M)",                       "$(P)Mtr")                    # Standard Motor record which groups many of the motor's features

# DMC Control records
# Source: <Galil support top directory>/GalilSup/Db/galil_dmc_ctrl.template
alias(  "$(P)MODEL_MON",                  "$(P)ControllerModel-Mon")    # Controller model monitor
alias(  "$(P)ADDRESS_MON",                "$(P)ControllerAddr-Mon")     # Controller address monitor
alias(  "$(P)LIMITTYPE_STATUS",           "$(P)LimSwType-Sts")          # Limit switch type configuration (read)
alias(  "$(P)LIMITTYPE_CMD",              "$(P)LimSwType-Sel")          # Limit switch type configuration (set)
alias(  "$(P)HOMETYPE_STATUS",            "$(P)HomeSwType-Sts")         # Home switch type configuration (read)
alias(  "$(P)HOMETYPE_CMD",               "$(P)HomeSwType-Sel")         # Home switch type configuration (set)
alias(  "$(P)ETHADDR_MON",                "$(P)MacAddr-Mon")            # Controller MAC address monitor
alias(  "$(P)SERIALNUM_MON",              "$(P)SerialNr-Mon")           # Controller serial number monitor
alias(  "$(P)COMMERR_STATUS",             "$(P)CommErr-Mon")            # Communication Error monitor
alias(  "$(P)START_STATUS",               "$(P)ControllerStart-Mon")    # Controller startup status monitor
alias(  "$(P)DEFER_STATUS",               "$(P)DeferredMove-Sts")       # Deferred moves option (read)
alias(  "$(P)DEFER_CMD",                  "$(P)DeferredMove-Sel")       # Deferred moves option (set)
alias(  "$(P)UPLOAD_CMD",                 "$(P)UploadUserArray-Cmd")    # Upload user array command
alias(  "$(P)UPLOAD_STATUS",              "$(P)UploadUserArray-Mon")    # Array upload status monitor
alias(  "$(P)DEFER_MODE_STATUS",          "$(P)DeferredMoveMode-Sts")   # Deferred move mode (read)
alias(  "$(P)DEFER_MODE_CMD",             "$(P)DeferredMoveMode-Sel")   # Deferred move mode (set)
alias(  "$(P)ERROR_MON",                  "$(P)ControllerErr-Mon")      # Controller error monitor
alias(  "$(P)SEND_STR_CMD",               "$(P)Send-Cmd")               # Send a command string to the controller
alias(  "$(P)SEND_STR_MON",               "$(P)Response-Mon")           # Last response string received after sending a command to the controller using "Send-Cmd"
alias(  "$(P)SEND_STRVAL_MON",            "$(P)ReponseVal-Mon")         # Display last response received when it is a number

# Extra features not provided by Motor Record
# Source: <Galil support top directory>/GalilSup/Db/galil_motor_extras.template
alias(  "$(P)$(M)_ESTALL_STATUS",         "$(P)Estall-Sts")             # Encoder stall status
alias(  "$(P)$(M)_ESTALLTIME_MON",        "$(P)EstallTime-RB")          # Estall time read
alias(  "$(P)$(M)_ESTALLTIME_SP",         "$(P)EstallTime-SP")          # Estall time set
alias(  "$(P)$(M)_STEPSMOOTH_MON",        "$(P)StepSmooth-RB")          # Step smoothing read
alias(  "$(P)$(M)_STEPSMOOTH_SP",         "$(P)StepSmooth-SP")          # Step smoothing set
alias(  "$(P)$(M)_MCONN_STATUS",          "$(P)MtrConnect-Mon")         # Connection status
alias(  "$(P)$(M)_UINDEX_STATUS",         "$(P)UseIdx-Sts")             # Use encoder index when homing (read)
alias(  "$(P)$(M)_UINDEX_CMD",            "$(P)UseIdx-Sel")             # Use encoder index when homing (set)
alias(  "$(P)$(M)_USWITCH_STATUS",        "$(P)UseSw-Sts")              # Use limit switch when homing (read)
alias(  "$(P)$(M)_USWITCH_CMD",           "$(P)UseSw-Sel")              # Use limit switch when homing (set)
alias(  "$(P)$(M)_USERDATA_MON",          "$(P)UserData-Mon")           # User data (read)
alias(  "$(P)$(M)_USERDATADEADB_SP",      "$(P)UserDataDeadBand-SP")    # User data deadband (set)
alias(  "$(P)$(M)_JAH_STATUS",            "$(P)JogAfterHome-Sts")       # Jog after home (read)
alias(  "$(P)$(M)_JAH_CMD",               "$(P)JogAfterHome-Sel")       # Jog after home (set)
alias(  "$(P)$(M)_JAHV_MON",              "$(P)JogAfterHome-RB")        # Jog after home to position (read)
alias(  "$(P)$(M)_JAHV_SP",               "$(P)JogAfterHome-SP")        # Jog after home to position (set)
alias(  "$(P)$(M)_EGUAFTLIMIT_MON",       "$(P)EguAfterLim-RB")         # EGU after limit (read)
alias(  "$(P)$(M)_EGUAFTLIMIT_SP",        "$(P)EguAfterLim-SP")         # EGU after limit (set)
alias(  "$(P)$(M)_STATUS_POLL_DELAY_CMD", "$(P)PollPeriod-SP")          # Control poll period for axis and encoder status (read)
alias(  "$(P)$(M)_STATUS_POLL_DELAY_MON", "$(P)PollPeriod-RB")          # Control poll period for axis and encoder status (set)
alias(  "$(P)$(M)_HOMEALLOWED_CMD",       "$(P)HomeEnblDir-Sel")        # Enable directions for homing (set)
alias(  "$(P)$(M)_HOMEALLOWED_STATUS",    "$(P)HomeEnblDir-Sts")        # Enable directions for homing (read)
alias(  "$(P)$(M)_STOPDELAY_MON",         "$(P)StopDelay-RB")           # Motor stop delay (read)
alias(  "$(P)$(M)_STOPDELAY_SP",          "$(P)StopDelay-SP")           # Motor stop delay (set)
alias(  "$(P)$(M)_AMPGAIN_CMD",           "$(P)AmpGain-Sel")            # Amplifier gain (set)
alias(  "$(P)$(M)_AMPGAIN_STATUS",        "$(P)AmpGain-Sts")            # Amplifier gain (read)
alias(  "$(P)$(M)_AMPCLGAIN_CMD",         "$(P)AmpCurrLoopGain-Sel")    # Amplifier current loop gain (set)
alias(  "$(P)$(M)_AMPCLGAIN_STATUS",      "$(P)AmpCurrLoopGain-Sts")    # Amplifier current loop gain (read)
alias(  "$(P)$(M)_AMPLC_SP",              "$(P)LowCurrMode-SP")         # Specify period before going to low curr mode, or disable low curr mode for n=0 (set)
alias(  "$(P)$(M)_AMPLC_MON",             "$(P)LowCurrMode-RB")         # Specify period before going to low curr mode, or disable low curr mode for n=0 (read)
alias(  "$(P)$(M)_ERRLIMIT_SP",           "$(P)PosErrLim-SP")           # Position error limit in counts (set)
alias(  "$(P)$(M)_ERRLIMIT_MON",          "$(P)PosErrLim-RB")           # Position error limit in counts (read)
alias(  "$(P)$(M)_ERR_MON",               "$(P)PosErr-Mon")             # Position error monitor
alias(  "$(P)$(M)_VELOCITYRAW_MON",       "$(P)VeloRaw-Mon")            # Velocity monitor in counts/second
alias(  "$(P)$(M)_VELOCITYEGU_MON",       "$(P)VeloEgu-Mon")            # Velocity monitor in engineering units
alias(  "$(P)$(M)_OFFONERR_CMD",          "$(P)ErrLimType-Sel")         # Error state source (set)
alias(  "$(P)$(M)_OFFONERR_STATUS",       "$(P)ErrLimType-Sts")         # Error state source (read)
alias(  "$(P)$(M)_AXIS_STATUS",           "$(P)Axis-Mon")               # Selected Axis monitor
alias(  "$(P)$(M)_MTRTYPE_CMD",           "$(P)MtrType-Sel")            # Motor type (set)
alias(  "$(P)$(M)_MTRTYPE_STATUS",        "$(P)MtrType-Sts")            # Motor type (read)
alias(  "$(P)$(M)_MENCTYPE_CMD",          "$(P)MainEncType-Sel")        # Main encoder type (set)
alias(  "$(P)$(M)_MENCTYPE_STATUS",       "$(P)MainEncType-Sts")        # Main encoder type (read)
alias(  "$(P)$(M)_AENCTYPE_CMD",          "$(P)AuxEncType-Sel")         # Auxiliar encoder typw (set)
alias(  "$(P)$(M)_AENCTYPE_STATUS",       "$(P)AuxEncType-Sts")         # Auxiliar encoder typw (read)
alias(  "$(P)$(M)_WLP_CMD",               "$(P)LimProtectEnbl-Sel")     # Limit protection enable (set)
alias(  "$(P)$(M)_WLP_STATUS",            "$(P)LimProtectEnbl-Sts")     # Limit protection enable (read)
alias(  "$(P)$(M)_WLPACTIVE_STATUS",      "$(P)LimProtect-Mon")         # Limit protection state monitor
alias(  "$(P)$(M)_AUTOONOFF_CMD",         "$(P)AutoOnOff-Sel")          # Motor auto power on/off between moves (set)
alias(  "$(P)$(M)_AUTOONOFF_STATUS",      "$(P)AutoOnOff-Sts")      # Motor auto power on/off between moves (read)
alias(  "$(P)$(M)_ONDELAY_MON",           "$(P)AutoOnDelay-RB")         # Motor auto power on delay (read)
alias(  "$(P)$(M)_ONDELAY_SP",            "$(P)AutoOnDelay-SP")         # Motor auto power on delay (set)
alias(  "$(P)$(M)_OFFDELAY_MON",          "$(P)AutoOffDelay-RB")        # Motor auto power off delay (read)
alias(  "$(P)$(M)_OFFDELAY_SP",           "$(P)AutoOffDelay-SP")        # Motor auto power off delay (set)
alias(  "$(P)$(M)_BRAKE_CMD",             "$(P)Brake-Cmd")              # Motor brake manual control (set)
alias(  "$(P)$(M)_BRAKE_STATUS",          "$(P)Brake-Mon")              # Motor brake manual control (read)
alias(  "$(P)$(M)_AUTOBRAKE_CMD",         "$(P)AutoBrakeEnbl-Sel")      # Motor auto brake enable (set)
alias(  "$(P)$(M)_AUTOBRAKE_STATUS",      "$(P)AutoBrakeEnbl-Sts")      # Motor auto brake enable (read)
alias(  "$(P)$(M)_BRAKEPORT_MON",         "$(P)AutoBrakeiDigPort-RB")   # Motor brake digital port (read)
alias(  "$(P)$(M)_BRAKEPORT_SP",          "$(P)AutoBrakeDigPort-SP")    # Motor brake digital port (set)
alias(  "$(P)$(M)_BRAKEONDELAY_MON",      "$(P)AutoBrakeDelay-RB")      # Motor auto brake on delay (read)
alias(  "$(P)$(M)_BRAKEONDELAY_SP",       "$(P)AutoBrakeDelay-SP")      # Motor auto brake on delay (set)
alias(  "$(P)$(M)_LIMITDISABLE_CMD",      "$(P)LimSwDsbl-Sel")          # Disable limit switches mode (set)
alias(  "$(P)$(M)_LIMITDISABLE_STATUS",   "$(P)LimSwDsbl-Sts")          # Disable limit switches mode (read)
alias(  "$(P)$(M)_ON_STATUS",             "$(P)AmpEnbl-Sts")            # Turn galil amplifier on/off (read)
alias(  "$(P)$(M)_ON_CMD",                "$(P)AmpEnbl-Sel")            # Turn galil amplifier on/off (set)

# Digital outputs control
# Source: <Galil support top directory>/GalilSup/Db/galil_digital_out_bit.template
alias(  "$(P)$(DIG_OUT0)_STATUS",         "$(P)$(DIG_OUT0)-Sts")        # Digital output bit 0 state (read)
alias(  "$(P)$(DIG_OUT0)_CMD",            "$(P)$(DIG_OUT0)-Sel")        # Digital output bit 0 state (set)
alias(  "$(P)$(DIG_OUT1)_STATUS",         "$(P)$(DIG_OUT1)-Sts")        # Digital output bit 1 state (read)
alias(  "$(P)$(DIG_OUT1)_CMD",            "$(P)$(DIG_OUT1)-Sel")        # Digital output bit 1 state (set)
alias(  "$(P)$(DIG_OUT2)_STATUS",         "$(P)$(DIG_OUT2)-Sts")        # Digital output bit 2 state (read)
alias(  "$(P)$(DIG_OUT2)_CMD",            "$(P)$(DIG_OUT2)-Sel")        # Digital output bit 2 state (set)
alias(  "$(P)$(DIG_OUT3)_STATUS",         "$(P)$(DIG_OUT3)-Sts")        # Digital output bit 3 state (read)
alias(  "$(P)$(DIG_OUT3)_CMD",            "$(P)$(DIG_OUT3)-Sel")        # Digital output bit 3 state (set)

# Digital inputs control
# Source: <Galil support top directory>/GalilSup/Db/galil_digital_in_bit.template
alias(  "$(P)$(DIG_IN0)_STATUS",          "$(P)$(DIG_IN0)-Mon")         # Digital input bit 0 monitor
alias(  "$(P)$(DIG_IN1)_STATUS",          "$(P)$(DIG_IN1)-Mon")         # Digital input bit 1 monitor
alias(  "$(P)$(DIG_IN2)_STATUS",          "$(P)$(DIG_IN2)-Mon")         # Digital input bit 2 monitor
alias(  "$(P)$(DIG_IN3)_STATUS",          "$(P)$(DIG_IN3)-Mon")         # Digital input bit 3 monitor
alias(  "$(P)$(DIG_IN4)_STATUS",          "$(P)$(DIG_IN4)-Mon")         # Digital input bit 4 monitor
alias(  "$(P)$(DIG_IN5)_STATUS",          "$(P)$(DIG_IN5)-Mon")         # Digital input bit 5 monitor
alias(  "$(P)$(DIG_IN6)_STATUS",          "$(P)$(DIG_IN6)-Mon")         # Digital input bit 6 monitor
alias(  "$(P)$(DIG_IN7)_STATUS",          "$(P)$(DIG_IN7)-Mon")         # Digital input bit 7 monitor

# Analog outputs control
# Source: <Galil support top directory>/GalilSup/Db/galil_analog_out.template
alias(  "$(P)$(ANALOG_OUT0)_MON",         "$(P)$(ANALOG_OUT0)-RB")      # Analog output 0 state (read)
alias(  "$(P)$(ANALOG_OUT0)_SP",          "$(P)$(ANALOG_OUT0)-SP")      # Analog output 0 state (set)
alias(  "$(P)$(ANALOG_OUT0)Deadb_SP",     "$(P)$(ANALOG_OUT0)DeadBand-SP")     # Analog output 0 deadband state (set)
alias(  "$(P)$(ANALOG_OUT0)Deadb_SP",     "$(P)$(ANALOG_OUT0)DeadBand-RB")     # Analog output 0 deadband dummy readback

alias(  "$(P)$(ANALOG_OUT1)_MON",         "$(P)$(ANALOG_OUT1)-RB")      # Analog output 1 state (read)
alias(  "$(P)$(ANALOG_OUT1)_SP",          "$(P)$(ANALOG_OUT1)-SP")      # Analog output 1 state (set)
alias(  "$(P)$(ANALOG_OUT1)Deadb_SP",     "$(P)$(ANALOG_OUT1)DeadBand-SP")     # Analog output 1 deadband state (set)
alias(  "$(P)$(ANALOG_OUT1)Deadb_SP",     "$(P)$(ANALOG_OUT1)DeadBand-RB")     # Analog output 1 deadband dummy readback

# Analog inputs control
# Source: <Galil support top directory>/GalilSup/Db/galil_analog_in.template
alias(  "$(P)$(ANALOG_IN0)_MON",         "$(P)$(ANALOG_IN0)-Mon")       # Analog input 0 monitor
alias(  "$(P)$(ANALOG_IN0)Deadb_SP",     "$(P)$(ANALOG_IN0)DeadBand-SP")     # Analog input 0 deadband state (set)
alias(  "$(P)$(ANALOG_IN0)Deadb_SP",     "$(P)$(ANALOG_IN0)DeadBand-RB")     # Analog input 0 deadband dummy readback

alias(  "$(P)$(ANALOG_IN1)_MON",         "$(P)$(ANALOG_IN1)-Mon")       # Analog input 1 monitor
alias(  "$(P)$(ANALOG_IN1)Deadb_SP",     "$(P)$(ANALOG_IN1)DeadBand-SP")     # Analog input 1 deadband state (set)
alias(  "$(P)$(ANALOG_IN1)Deadb_SP",     "$(P)$(ANALOG_IN1)DeadBand-RB")     # Analog input 1 deadband dummy readback

# BiSS protocol support
alias(  "$(P)$(M)_BISSSTAT_CRC",         "$(P)BiSSCRC-Mon")             # BiSS CRC Status
alias(  "$(P)$(M)_BISSSTAT_ERROR",       "$(P)BiSSErr-Mon")             # BiSS Error Status
alias(  "$(P)$(M)_BISSSTAT_POLL",        "$(P)BiSSPoll-Sts")            # Poll BiSS Status
alias(  "$(P)$(M)_BISSSTAT_TIMEOUT",     "$(P)BiSSTimeout-Mon")         # BiSS Timeout
alias(  "$(P)$(M)_BISSSTAT_WARN",        "$(P)BiSSWarn-Mon")            # BiSS Warning
alias(  "$(P)BISSCAPABLE_STATUS",        "$(P)BiSSCapable-Mon")         # Is device BiSS Capable
alias(  "$(P)$(M)_BISSSTAT_POLL_CMD",    "$(P)BiSSPoll-Sel")            # Poll BISS Status
alias(  "$(P)$(M)_BISSCD_MON",           "$(P)BiSSClkDiv-RB")           # BiSS Clock Div
alias(  "$(P)$(M)_BISSDATA1_MON",        "$(P)BiSSNumBits1-RB")         # Number of Data Bits in segment 1
alias(  "$(P)$(M)_BISSDATA2_MON",        "$(P)BiSSNumBits2-RB")         # Number of Data Bits in segment 2
alias(  "$(P)$(M)_BISSZP_MON",           "$(P)BiSSNumZeroPad-RB")       # Number of Zero Padding Bits
alias(  "$(P)$(M)_BISSCD_SP",            "$(P)BiSSClkDiv-SP")           # BiSS Clock Div Status
alias(  "$(P)$(M)_BISSDATA1_SP",         "$(P)BiSSNumBits1-SP")         # Set Number of Data Bits in segment 1
alias(  "$(P)$(M)_BISSDATA2_SP",         "$(P)BiSSNumBits2-SP")         # Set Number of Data Bits in segment 2
alias(  "$(P)$(M)_BISSZP_SP",            "$(P)BiSSNumZeroPad-SP")       # Number of Zero Padding Bits
alias(  "$(P)$(M)_BISSINPUT_STATUS",     "$(P)BiSSIn-Sts")              # BiSS Input Status
alias(  "$(P)$(M)_BISSLEVEL_STATUS",     "$(P)BiSSLvl-Sts")             # BiSS Active Level Status
alias(  "$(P)$(M)_BISSINPUT_CMD",        "$(P)BiSSIn-Sel")              # Select BiSS Input
alias(  "$(P)$(M)_BISSLEVEL_CMD",        "$(P)BiSSLvl-Sel")             # Select BiSS Active Level

#####################################################################
# HIGH LEVEL FEATURES
#
# Desc: Records that provide high level features to the IOC,
# in order to allow easy control of it.

# Homing - Depending on DIR, move back to home using jog function
# Unlike the Home functions, the Jog functions adapt themselves to the DIR value
record(bo, "$(P)HomeToLimSw-Cmd"){
  field(DESC, "Homing command")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)ValidHomeToLimSw")
}

# Validate the homing command
record(calcout, "$(P)ValidHomeToLimSw"){
  field(DESC, "Home command calc")
  field(INPA, "$(P)HomeToLimSw-Cmd")
  field(CALC, "A=0?0:1")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)$(M).JOGR PP")
}

# State of homing procedure (using limit switch)
# set by sequencer state machine
record(stringin, "$(P)HomingState-Mon"){
  field(DESC, "State of homing using limit switch")
}

# Reset Position After Homing
# This record is used by a sequencer state machine
record(bo, "$(P)RstPosAfterHome-Sel"){
  field(DESC, "Reset position after homing")
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(FLNK, "$(P)RstPosAfterHome-Sts")
}

# Reset Position After Homing status
# This record is used by a sequencer state machine
record(bi, "$(P)RstPosAfterHome-Sts"){
  field(DESC, "Reset position after homing status")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(INP, "$(P)RstPosAfterHome-Sel")
}

# Set Position to Home Reference Position
# Set the motor commanded and readback positions to a given value
# without moving the motor.
record(bo, "$(P)RstPos-Cmd"){
  field(DESC, "Rst motor position without moving motor")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)ValidRstPos")
}

# Validate the reset position command
record(calcout, "$(P)ValidRstPos"){
  field(DESC, "Validate rst position cmd")
  field(INPA, "$(P)RstPos-Cmd")
  field(CALC, "A")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)RstPosSeq.PROC PP")
}

# Sequence for setting position without moving motor
record(sseq, "$(P)RstPosSeq"){
  field(DESC, "Set pos without moving motor sequence")
  field(SELM, "All")
  field(STR1, "Set")
  field(DOL2, "$(P)RefHomePos-RB")
  field(STR3, "Use")
  field(LNK1, "$(P)$(M).SET CA")
  field(LNK2, "$(P)$(M).VAL CA")
  field(LNK3, "$(P)$(M).SET CA")
  field(WAIT1, "Wait")                                                # Wait for link 1 to finish processing
  field(WAIT2, "Wait")                                                # Wait for link 2 to finish processing
  field(WAIT3, "Wait")                                                # Wait for link 3 to finish processing
}

# Reference position for Home
record(ao, "$(P)RefHomePos-SP"){
  field(DESC, "Reference position for Home")
  field(PINI, "YES")
  field(PREC, "$(PREC)")
  field(FLNK, "$(P)RefHomePos-RB")
}

# Reference position for Home readback
record(ai, "$(P)RefHomePos-RB"){
  field(DESC, "Reference position for Home RB")
  field(PREC, "$(PREC)")
  field(INP, "$(P)RefHomePos-SP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

#####################################################################
# HIGH LEVEL RECORDS FOR MOTOR FIELDS
#
# Desc: High Level records that fit the most relevant Motor Record
# fields into the Sirius Naming Standard.

# DIFF - Difference between motor DVAL and DRBV.
record(ai, "$(P)PosDiff-Mon"){
  field(DESC, "Encoder read and commanded position diff")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(INP, "$(P)$(M).DIFF CPP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

# DMOV - Done moving to value.
record(bi, "$(P)DoneMov-Mon"){
  field(DESC, "Motor is done moving flag")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(INP, "$(P)$(M).DMOV CPP")
}

# HLS - At High Limit Switch.
record(bi, "$(P)HighLimSw-Mon"){
  field(DESC, "At high limit switch flag")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(INP, "$(P)$(M).HLS CPP")
}

# LLS - At Low Limit Switch.
record(bi, "$(P)LowLimSw-Mon"){
  field(DESC, "At low limit switch flag")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(INP, "$(P)$(M).LLS CPP")
}

# RBV - User Readback Value.
record(ai, "$(P)EncPos-Mon"){
  field(DESC, "Encoder position")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(INP, "$(P)$(M).RBV CPP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

# RLV - Relative Value.
record(ao, "$(P)MoveRelative-Cmd"){
  field(DESC, "Move a relative distance")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(OUT, "$(P)$(M).RLV PP")
}

# STOP - Stop Move.
record(bo, "$(P)Stop-Cmd"){
  field(DESC, "Stop motor command")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)StopCalc")
}

# Validate stop motor command
record(calcout, "$(P)StopCalc"){
  field(DESC, "Validate stop command")
  field(INPA, "$(P)Stop-Cmd")
  field(CALC, "A")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)$(M).STOP PP")
}

# TWF - Tweak motor Forward.
record(bo, "$(P)TweakFwd-Cmd"){
  field(DESC, "Move motor a tweak step size forward")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(OUT, "$(P)$(M).TWF PP")
}

# TWR - Tweak motor Reverse.
record(bo, "$(P)TweakBack-Cmd"){
  field(DESC, "Move motor a tweak step size back")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(OUT, "$(P)$(M).TWR PP")
}

# TWV - Tweak Step Size (EGU).
record(ao, "$(P)TweakStep-SP"){
  field(DESC, "Step size used in tweak moves")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(OUT, "$(P)$(M).TWV PP")
  field(FLNK, "$(P)TweakStep-RB")
}

# Tweak Step Size Readback
record(ai, "$(P)TweakStep-RB"){
  field(DESC, "Step size used in tweak moves RB")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(INP, "$(P)$(M).TWV CPP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

# VAL - User Desired Absolute Position Value.
record(ao, "$(P)AbsPos-SP"){
  field(DESC, "Move to an absolute position")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(OUT, "$(P)$(M).VAL PP")
}

# Absolute Position Readback Value.
record(ai, "$(P)AbsPos-RB"){
  field(DESC, "Absolute position RB")
  field(EGU, "$(EGU)")
  field(PREC, "$(PREC)")
  field(INP, "$(P)$(M).VAL CPP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

#####################################################################
# AUTO CONFIGURATION
#
# Desc: High Level auto-configuration operations.

# Auto update jog acceleration
# Since jog is used by high level for homing, it is the homing acceleration
record(calcout, "$(P)JogAccAutoConfig"){
  field(DESC, "Transform acc. period to jog acc.")
  field(PINI, "YES")
  field(INPA, "$(P)$(M).ACCL CPP")
  field(INPB, "$(P)$(M).VELO CPP")
  field(INPC, "$(P)$(M).JAR CPP")
  field(CALC, "C#(B/A)?1:0")
  field(OCAL, "B/A")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(M).JAR PP")
}

# Automatically set Jog velocity so that
# it is the same as the motor velocity
record(calcout, "$(P)JogVelAutoConfig"){
  field(DESC, "Keep jog vel equal to motor vel")
  field(PINI, "YES")
  field(INPA, "$(P)$(M).VELO CPP")
  field(INPB, "$(P)$(M).JVEL CPP")
  field(CALC, "A#B")                                                  # Only continue if jog velo different from motor velo
  field(OCAL, "A")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(M).JVEL PP")                                      # Jog acceleration <= motor acceleration
}

# Automatically turn motor on/off
# after a controller disconnection/reconnection
record(calcout, "$(P)AutoMotorEnbl"){
  field(DESC, "Auto enbl motor after disconnection")
  field(INPA, "$(P)COMMERR_STATUS CPP")
  field(CALC, "A")
  field(OOPT, "Transition To Zero")                                   # Recovery after disconnection
  field(OUT, "$(P)$(M)_ON_CMD.PROC PP")                               # Process amplifier enbl record
}

#####################################################################
# MACRO BASED CONFIGURATION
#
# Desc: Records used to overwrite settings based on macro values.
#       Undefined macros DO NOT cause overwriting of the corresponding
#       parameter.

# MOTOR ON/OFF AND MOTOR TYPE

# Value of motor on macro passed
# by the user
record(stringin, "$(P)MtrOnMacro-Cte"){
  field(DESC, "Motor on/off macro passed by user")
  field(VAL, "$(MTRON)")
}

# Value of motor type macro passed
# by the user
record(stringin, "$(P)MtrTypeMacro-Cte"){
  field(DESC, "Motor type macro passed by user")
  field(VAL, "$(MTRTYPE)")
}

record(calcout, "$(P)MtrOffWhileConfig"){
  field(DESC, "Turn motor off for configuration")
  field(PINI, "YES")
  field(INPA, "$(P)AmpEnbl-Sel")
  field(INPB, "$(P)AmpEnbl-Sel")
  field(CALC, "B:=A;0")
  field(OUT, "$(P)AmpEnbl-Sel PP")
  field(FLNK, "$(P)ApplyMtrTypeMacro")
}

# Initialize $(P)MtrType-Sel if a macro
# was passed on startup by the user
record(scalcout, "$(P)ApplyMtrTypeMacro"){
  field(DESC, "Initialize motor type if macro not empty")
  field(INAA, "$(P)MtrTypeMacro-Cte")
  field(CALC, "len(AA)=0?0:1")
  field(OCAL, "AA")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(ODLY, "2")                                                    # Wait a little so amp can be turned off
  field(OUT, "$(P)MtrType-Sel PP")
  field(FLNK, "$(P)ApplyMtrTypeSaved")
}

# Initialize $(P)MtrType-Sel with autosaved
# value if macro was not passed
record(calcout, "$(P)ApplyMtrTypeSaved"){
  field(DESC, "Process motor type to receive saved val")
  field(INPA, "$(P)ApplyMtrTypeMacro")
  field(CALC, "A=0")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)MtrType-Sel.PROC PP")
  field(FLNK, "$(P)ApplyMtrOnMacro")
}

# Initialize $(P)AmpEnl-Sel if a macro
# was passed on startup by the user
record(scalcout, "$(P)ApplyMtrOnMacro"){
  field(DESC, "Initialize motor on if macro not empty")
  field(INAA, "$(P)MtrOnMacro-Cte")
  field(CALC, "len(AA)=0?0:1")
  field(OCAL, "AA")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)AmpEnbl-Sel PP")
  field(FLNK, "$(P)ApplyMtrOnSaved")
}

# Initialize $(P)AmpEnbl-Sel with autosaved
# value if macro was not passed
record(calcout, "$(P)ApplyMtrOnSaved"){
  field(DESC, "Restore motor on with saved val")
  field(INPA, "$(P)ApplyMtrOnMacro")
  field(INPB, "$(P)MtrOffWhileConfig.B")
  field(CALC, "A=0")
  field(OCAL, "B")
  field(DOPT, "Use OCAL")
  field(OOPT, "When Non-zero")
  field(ODLY, "1")                                                    # Give time to controller to process cmds
  field(OUT, "$(P)AmpEnbl-Sel PP")
}

# AMPLIFIER GAIN

# Value of amplifier gain macro passed
# by the user
record(stringin, "$(P)AmpGainMacro-Cte"){
  field(DESC, "Amp gain macro passed by user")
  field(VAL, "$(AMP_GAIN)")
}

# Initialize $(P)AmpGain-Sel if a macro
# was passed on startup by the user
record(scalcout, "$(P)ApplyAmpGainMacro"){
  field(DESC, "Initialize amp gain if macro not empty")
  field(PINI, "YES")
  field(INAA, "$(P)AmpGainMacro-Cte")
  field(CALC, "len(AA)=0?0:1")
  field(OCAL, "AA")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(ODLY, "2")                                                    # Wait a little bit so that the motor type can be set
  field(OUT, "$(P)AmpGain-Sel PP")
}

# DIRECTION

# Value of direction passed by the user
record(stringin, "$(P)DirMacro-Cte"){
  field(DESC, "User direction macro passed by user")
  field(VAL, "$(DIR)")
}

# Initialize $(P)$(M).DIR if a macro
# was passed on startup by the user
record(scalcout, "$(P)ApplyDirMacro"){
  field(DESC, "Init user direction if macro not empty")
  field(PINI, "YES")
  field(INAA, "$(P)DirMacro-Cte")
  field(CALC, "len(AA)=0?0:1")
  field(OCAL, "AA")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)$(M).DIR PP")
}

# ENCODER TYPE

# Value of main encoder type passed by the user
record(stringin, "$(P)EncTypeMacro-Cte"){
  field(DESC, "Main encoder type macro passed by user")
  field(VAL, "$(ENC_TYPE)")
}

# Initialize $(P)$(M)_MENCTYPE_CMD if a macro
# was passed on startup by the user
record(scalcout, "$(P)ApplyEncTypeMacro"){
  field(DESC, "Init encoder type if macro not empty")
  field(PINI, "YES")
  field(INAA, "$(P)EncTypeMacro-Cte")
  field(CALC, "len(AA)=0?0:1")
  field(OCAL, "AA")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)$(M)_MENCTYPE_CMD PP")
}

# BISS POLL

# Value of BiSS poll passed by the user
record(stringin, "$(P)BiSSPollMacro-Cte"){
  field(DESC, "BiSS poll macro passed by user")
  field(VAL, "$(BISS_POLL)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSSTAT_POLL_CMD, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSPollMacro"){
  field(DESC, "Check if BiSS poll macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSPollMacro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSPoll.PROC PP")
}

record(sseq, "$(P)RestoreBiSSPoll"){
  field(DESC, "Get BiSS poll from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSPollMacro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSPollMacro-Cte")
  field(LNK1, "$(P)$(M)_BISSSTAT_POLL_CMD.PROC PP")
  field(LNK2, "$(P)$(M)_BISSSTAT_POLL_CMD PP")
}

# BISS CLOCK DIVIDER

# Value of BiSS Clock Divider passed by the user
record(stringin, "$(P)BiSSClkDivMacro-Cte"){
  field(DESC, "BiSS clock div macro passed by user")
  field(VAL, "$(BISS_CLKDIV)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSCD_SP, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSClkDivMacro"){
  field(DESC, "Check if BiSS clock div macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSClkDivMacro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSClkDiv.PROC PP")
}

record(sseq, "$(P)RestoreBiSSClkDiv"){
  field(DESC, "Get BiSS clk div from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSClkDivMacro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSClkDivMacro-Cte")
  field(LNK1, "$(P)$(M)_BISSCD_SP.PROC PP")
  field(LNK2, "$(P)$(M)_BISSCD_SP PP")
}

# BISS DATA 1

# Value of BiSS Data 1 passed by the user
record(stringin, "$(P)BiSSData1Macro-Cte"){
  field(DESC, "BiSS Data 1 macro passed by user")
  field(VAL, "$(BISS_DATA1)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSDATA1_SP, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSData1Macro"){
  field(DESC, "Check if BiSS data 1 macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSData1Macro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSData1.PROC PP")
}

record(sseq, "$(P)RestoreBiSSData1"){
  field(DESC, "Get BiSS data 1 from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSData1Macro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSData1Macro-Cte")
  field(LNK1, "$(P)$(M)_BISSDATA1_SP.PROC PP")
  field(LNK2, "$(P)$(M)_BISSDATA1_SP PP")
}

# BISS DATA 2

# Value of BiSS Data 2 passed by the user
record(stringin, "$(P)BiSSData2Macro-Cte"){
  field(DESC, "BiSS Data 2 macro passed by user")
  field(VAL, "$(BISS_DATA2)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSDATA2_SP, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSData2Macro"){
  field(DESC, "Check if BiSS data 2 macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSData2Macro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSData2.PROC PP")
}

record(sseq, "$(P)RestoreBiSSData2"){
  field(DESC, "Get BiSS data 2 from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSData2Macro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSData2Macro-Cte")
  field(LNK1, "$(P)$(M)_BISSDATA2_SP.PROC PP")
  field(LNK2, "$(P)$(M)_BISSDATA2_SP PP")
}

# BISS ZERO PADDING

# Value of BiSS Zero Padding passed by the user
record(stringin, "$(P)BiSSZeroPadMacro-Cte"){
  field(DESC, "BiSS Zero Pad macro passed by user")
  field(VAL, "$(BISS_ZEROPAD)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSZP_SP, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSZeroPadMacro"){
  field(DESC, "Check if BiSS zero pad macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSZeroPadMacro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSZeroPad.PROC PP")
}

record(sseq, "$(P)RestoreBiSSZeroPad"){
  field(DESC, "Get BiSS zero pad from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSZeroPadMacro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSZeroPadMacro-Cte")
  field(LNK1, "$(P)$(M)_BISSZP_SP.PROC PP")
  field(LNK2, "$(P)$(M)_BISSZP_SP PP")
}

# BISS INPUT

# Value of BiSS Input passed by the user
record(stringin, "$(P)BiSSInMacro-Cte"){
  field(DESC, "BiSS Input macro passed by user")
  field(VAL, "$(BISS_INPUT)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSINPUT_CMD, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSInMacro"){
  field(DESC, "Check if BiSS Input macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSInMacro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSIn.PROC PP")
}

record(sseq, "$(P)RestoreBiSSIn"){
  field(DESC, "Get BiSS Input from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSInMacro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSInMacro-Cte")
  field(LNK1, "$(P)$(M)_BISSINPUT_CMD.PROC PP")
  field(LNK2, "$(P)$(M)_BISSINPUT_CMD PP")
}

# BISS LEVEL

# Value of BiSS Level passed by the user
record(stringin, "$(P)BiSSLvlMacro-Cte"){
  field(DESC, "BiSS level macro passed by user")
  field(VAL, "$(BISS_LEVEL)")
}

# Decide whether use macro or autosaved value to
# initialize $(P)$(M)_BISSLEVEL_CMD, depending if
# a macro was passed on startup by the user
record(scalcout, "$(P)ApplyBiSSLvlMacro"){
  field(DESC, "Check if BiSS level macro is empty")
  field(PINI, "YES")
  field(INAA, "$(P)BiSSLvlMacro-Cte")
  field(CALC, "len(AA)=0?1:2")
  field(ODLY, "2")                                                    # Wait a little bit
  field(OUT, "$(P)RestoreBiSSLvl.PROC PP")
}

record(sseq, "$(P)RestoreBiSSLvl"){
  field(DESC, "Get BiSS level from save or macro")
  field(SELM, "Specified")
  field(SELL, "$(P)ApplyBiSSLvlMacro.VAL")
  field(DO1, "1")
  field(DOL2, "$(P)BiSSLvlMacro-Cte")
  field(LNK1, "$(P)$(M)_BISSLEVEL_CMD.PROC PP")
  field(LNK2, "$(P)$(M)_BISSLEVEL_CMD PP")
}

#####################################################################
# RECONNECTION ACTIONS
#
# Desc: Records used to restore some configurations when
#       the controller is reset but the IOC is not.

record(calcout, "$(P)RestoreAmpCurrLoopGain"){
  field(DESC, "Restore curr loop gain after reset")
  field(INPA, "$(P)CommErr-Mon CPP")
  field(CALC, "A")
  field(OOPT, "Transition To Zero")                                   # After a reconnect
  field(OCAL, "1")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)AmpCurrLoopGain-Sel.PROC PP")
}
